/*! Rappid v3.0.1 - HTML5 Diagramming Framework

Copyright (c) 2015 client IO

 2019-08-10 


This Source Code Form is subject to the terms of the Rappid License
, v. 2.0. If a copy of the Rappid License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/


var graph = new joint.dia.Graph();

// new code
// joint.setTheme('dark');
var paper = new joint.dia.Paper({
    width: 1000,
    height: 1000,
    gridSize: 10,
    drawGrid: true,
    model: graph, // Set graph as the model for paper
    defaultLink: function(elementView, magnet) {
        return new joint.shapes.standard.Link({
            attrs: { line: { stroke: '#ff0000' }}
        });
    },
    interactive: { linkMove: false },
    snapLinks: { radius: 70 },
    defaultConnectionPoint: { name: 'boundary' }
});

var paperScroller = new joint.ui.PaperScroller({
    paper: paper,
    autoResizePaper: true,
    cursor: 'grab'
});

document.querySelector('.paper-container').appendChild(paperScroller.el);
paperScroller.render().center();

// Custom Shape
// ------------

joint.dia.Element.define('myApp.MyShape', {
    attrs: {
        body: {
            refWidth: '100%',
            refHeight: '100%',
            strokeWidth: 2,
            stroke: '#000000',
            fill: '#FFFFFF'
        },
        label: {
            textVerticalAnchor: 'middle',
            textAnchor: 'middle',
            refX: '50%',
            refY: '50%',
            fontSize: 14,
            fill: '#333333'
        },
        root: {
            magnet: false // Disable the possibility to connect the body of our shape. Only ports can be connected.
        }
    },
    level: 10,
    ports: {
        groups: {
            'in': {
                markup: [{
                    tagName: 'circle',
                    selector: 'portBody',
                    attributes: { r: 12 }
                }],
                z: -1,
                attrs: {
                    portBody: {
                        magnet: true,
                        fill: '#7C68FC'
                    }
                },
                position: { name: 'left' },
                label: { position: { name: 'left' }}
            },
            'out': {
                markup: [{
                    tagName: 'circle',
                    selector: 'portBody',
                    attributes: { r: 12 }
                }],
                z: -1,
                attrs: {
                    portBody: {
                        magnet: true,
                        fill: '#7C68FC'
                    }
                },
                position: { name: 'right' },
                label: { position: { name: 'right' }}
            }
        }
    }
}, {
    markup: [{
        tagName: 'rect',
        selector: 'body'
    }, {
        tagName: 'text',
        selector: 'label'
    }]
});

// Stencil
// -------

var stencil = new joint.ui.Stencil({
    paper: paperScroller,
    scaleClones: true,
    width: 240,
    groups: {
        myShapesGroup1: { index: 1, label: ' My Shapes 1' },
        myShapesGroup2: { index: 2, label: ' My Shapes 2' }
    },
    dropAnimation: true,
    groupsToggleButtons: true,
    search: {
        '*': ['type', 'attrs/label/text']
    },
    layout: true  // Use default Grid Layout
});

document.querySelector('.stencil-container').appendChild(stencil.el);
stencil.render().load({
    myShapesGroup1: [{
        type: 'standard.Rectangle'
    }, {
        type: 'standard.Ellipse'
    }],
    myShapesGroup2: [{
        type: 'standard.Cylinder'
    }, {
        type: 'myApp.MyShape',
        attrs: { label: { text: 'Shape' }},
        ports: { items: [{ group: 'in' }, { group: 'out' }, { group: 'out' }] }
    }]
});

// Inspector
// --------

paper.on('element:pointerclick', function(elementView) {
    joint.ui.Inspector.create('.inspector-container', {
        cell: elementView.model,
        inputs: {
            'attrs/label/text': {
                type: 'text',
                label: 'Label',
                group: 'basic',
                index: 1
            },
            level: {
                type: 'range',
                min: 1,
                max: 10,
                unit: 'x',
                defaultValue: 6,
                label: 'Level',
                group: 'advanced',
                index: 2
            }
        },
        groups: {
            basic: {
                label: 'Basic',
                index: 1
            },
            advanced: {
                label: 'Advanced',
                index: 2
            }
        }
    });
});

// Halo
// ----

paper.on('element:pointerclick', function(elementView) {
    var handles = [{
        name: 'remove',
        position: 'nw',
        events: { pointerdown: 'removeElement' }
    }, {
        name: 'myCustomAction',
        position: 'ne',
        icon: 'data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7'
    }];
    if (!elementView.model.hasPorts()) {
        // Only shapes without ports will have the "link" handle in the Halo control panel. Shapes with ports can be connected by "dragging" ports.
        handles.push({
            name: 'link',
            position: 'e',
            events: { pointerdown: 'startLinking', pointermove: 'doLink', pointerup: 'stopLinking' }
        });
    }
    var halo = new joint.ui.Halo({
        cellView: elementView,
        handles: handles
    }).render();

    halo.on('action:myCustomAction:pointerdown', function(evt) {
        alert('My Control Button Clicked!');
    });
});

// Link Tools
// ----------

paper.on('link:pointerup', function(linkView) {
    paper.removeTools();
    var toolsView = new joint.dia.ToolsView({
        name: 'my-link-tools',
        tools: [
            new joint.linkTools.Vertices(),
            new joint.linkTools.SourceArrowhead(),
            new joint.linkTools.TargetArrowhead(),
            new joint.linkTools.Segments(),
            new joint.linkTools.Remove({ offset: -20, distance: 40 })
        ]
    });
    linkView.addTools(toolsView);
});

paper.on('blank:pointerdown', function() {
    paper.removeTools();
});

// Toolbar
// -------

var toolbar = new joint.ui.Toolbar({
    groups: {
        clear: { index: 1 },
        zoom: { index: 2 },
        import: { index: 3 },
        export: { index: 4 },
    },
    tools: [
        { type: 'button', name: 'clear', group: 'clear', text: 'Clear Diagram' },
        { type: 'button', name: 'export', group: 'export', text: 'Export to MS Visio' },
        { type: 'button', name: 'import', group: 'import', text: 'Import from MS Visio' },
        { type: 'zoom-out', name: 'zoom-out', group: 'zoom' },
        { type: 'zoom-in', name: 'zoom-in', group: 'zoom' }
    ],
    references: {
        paperScroller: paperScroller // built in zoom-in/zoom-out control types require access to paperScroller instance
    }
});

toolbar.on({
    'clear:pointerclick': graph.clear.bind(graph),
    'import:pointerclick': importFromVisio.bind(),
    'export:pointerclick': exportToVisio.bind(graph, paper)

});

document.querySelector('.toolbar-container').appendChild(toolbar.el);
toolbar.render();


// Working With Diagrams Programmatically
// --------------------------------------

// Add new element to the graph.
/*var myShape = new joint.shapes.myApp.MyShape({
    size: { width: 100, height: 100 },
    position: { x: 50, y: 50 },
    attrs: { label: { text: 'My Shape' }},
    level: 3,
    ports: { items: [{ id: 'in1', group: 'in' }, { group: 'out', id: 'out1' }] }
});*/
// graph.addCell(myShape);

// Get element from the graph and change its properties.
// myShape = graph.getElements()[0];
/*myShape.prop('attrs/label/text', 'My Updated Shape');
myShape.prop('size/width', 150);
myShape.prop('level', 2);
myShape.prop('attrs/body/fill', '#FE854F');*/

// Create a clone of an element.
// var myShape2 = myShape.clone();
// myShape2.translate(400, 0);
// graph.addCell(myShape2);

// Create a link that connects two elements.
// var myLink = new joint.shapes.standard.Link({
//     attrs: { line: { stroke: '#ff0000' }},
//     source: { id: myShape.id, port: 'out1' },
//     target: { id: myShape2.id, port: 'in1' }
// });
// graph.addCell(myLink);

graph.on('change:level', function(cell, level) {
    var color = (level > 8) ? '#ff0000' : '#ffffff';
    cell.prop('attrs/body/fill', color);
});

// prev code
if (window.File && window.FileReader && window.FileList && window.Blob) {
    document.querySelector('#files > input[type="file"]').addEventListener('change', handleFileSelect, false);
} else {
    alert('The File APIs are not fully supported in this browser.');
}

function handleFileSelect(evt) {
    var f = evt.target.files[0];
    var reader = new FileReader();
    reader.onload = (function(theFile) {
        return function(e) {
            var binaryData = e.target.result;
            var base64String = window.btoa(binaryData);
            try {
                graph.fromVisio(base64String, function(res) {
                    // console.log(res);
                    var jointShapes = [];
                    paper = new joint.dia.Paper({
                        el: document.getElementById('graph'),
                        model: graph,
                        width: res.paperOpt.width,
                        height: res.paperOpt.height,
                        gridSize: 10,
                        drawGrid: false
                    });
                    res.shapes.forEach(function(item) {
                        var shape;
                        var width = item.cell.width || 100;
                        var height = item.cell.height || 100;
                        var rotate = item.cell.rotate || 0;
                        var path = new joint.shapes.standard.Path({
                            attrs: {
                                body: {
                                    fill: item.cell.fill || res.paperOpt.defColor,
                                    stroke: item.cell.strokeColor || '#000',
                                    strokeWidth: item.cell.strokeWeight || 1,
                                    rx: item.cell.strokeRadius || 0,
                                    ry: item.cell.strokeRadius || 0
                                }
                            }
                        });
                        var Flag = joint.dia.Element.define('standard.Flag', {
                            attrs: {
                                pole: {
                                    width: 2,
                                    stroke: '#8b8793',
                                    fill: '#8b8793',
                                    refHeight: '100%'
                                },
                                flag: {
                                    flagD: ['M', 6, 0, '100%', '25%', 6, '50%', 'Z'],
                                    fill: 'red',
                                    stroke: 'transparent',
                                    strokeWidth: 5
                                }
                            }
                        }, {
                            markup: [{
                                tagName: 'rect',
                                selector: 'pole'
                            }, {
                                tagName: 'path',
                                selector: 'flag'
                            }]
                        }, {
                            // Element specific special attributes
                            attributes: {
                                flagD: {
                                    qualify: Array.isArray,
                                    set: function(value, refBBox) {
                                        var i = 0;
                                        var attrValue = value.map(function(data, index) {
                                            if (typeof data === 'string') {
                                                if (data.slice(-1) === '%') {
                                                    return parseFloat(data) / 100 * refBBox[((index - i) % 2) ? 'height' : 'width'];
                                                } else {
                                                    i++;
                                                }
                                            }
                                            return data;
                                        }).join(' ');
                                        return { d:  attrValue };
                                    }
                                }
                            }
                        });
                        var headeredRectangle = new joint.shapes.standard.HeaderedRectangle();
                        path.attr('label', item.text.label);
                        path.attr('text/fontFamily', item.text.fontFamily);
                        if (item.opt.type === 'Legend') {
                            headeredRectangle.attr('root/title', 'joint.shapes.standard.HeaderedRectangle');
                            headeredRectangle.attr('header/fill', 'lightgray');
                            headeredRectangle.attr('headerText/text', item.text);
                            shape = headeredRectangle;
                        } else if (item.opt.type === 'Ellipse' || item.opt.type === 'Circle') {
                            shape = new joint.shapes.standard.Ellipse({
                                attrs: {
                                    text: {
                                        'fontFamily': item.text.fontFamily
                                    },
                                    label: item.text.label
                                }});
                        } else if (item.opt.type === 'Rectangle') {
                            shape = new joint.shapes.standard.Rectangle({
                                attrs: {
                                    text: {
                                        'fontFamily': item.text.fontFamily
                                    },
                                    label: item.text.label
                                }});
                            if (item.text.rotate) {
                                shape.attr('text/transform', item.text.rotate);
                            }
                        } else if (item.opt.type === 'CBV item') {
                            shape = new joint.shapes.standard.Rectangle({});
                        } else if (item.opt.type === 'Icon item') {
                            shape = new Flag();
                            item.cell.fill = (item.cell.fill === 'none') ? 'red' : item.cell.fill;
                            shape.attr('flag/fill', item.cell.fill);
                        } else if (item.opt.type === 'Database') {
                            /*shape = new joint.shapes.standard.Cylinder({
                                attrs: {
                                    text: {
                                        'fontFamily': item.text.fontFamily
                                    },
                                    label: item.text.label
                                }});*/
                            path.attr('body/refD', item.opt.opt.path);
                            shape = path;
                        } else if (item.opt.type === 'Diamond') {
                            shape = new joint.shapes.standard.Polygon({
                                attrs: {
                                    body: {
                                        refPoints: item.opt.opt.path
                                    },
                                    text: {
                                        'fontFamily': item.text.fontFamily
                                    },
                                    label: item.text.label
                                }});
                        } else if (item.opt.type === 'Image') {
                            var image = new joint.shapes.standard.Image();
                            res.images.forEach(function(resImage) {
                                if (resImage.path === item.image) {
                                    image.attr('image/xlinkHref', resImage.str);
                                }
                            });
                            shape = image;
                        } else if (item.opt.type === 'Topic') {
                            path.attr('body/refD', 'M 1057.69 824.52 C 1046.7 821.05 1034.71 825.95 1029.8 835.92 C 1024.9 845.89 1028.64 857.77 1038.5 863.55 C 1028.43 866.87 1022.17 876.43 1023.5 886.47 C 1024.82 896.52 1033.37 904.32 1043.99 905.18 C 1041.49 915.31 1046.81 925.72 1056.75 930.13 C 1066.69 934.53 1078.52 931.72 1085.1 923.39 C 1089.86 933.14 1099.69 939.78 1110.95 940.85 C 1122.22 941.91 1133.24 937.25 1139.93 928.59 C 1149.94 935.67 1163.21 937.05 1174.59 932.19 C 1185.97 927.33 1193.69 916.99 1194.74 905.18 C 1205.69 906.51 1216.33 901.11 1221.23 891.72 C 1226.14 882.33 1224.24 871.02 1216.5 863.55 C 1225.85 853.85 1226.08 839.04 1217.04 829.08 C 1207.99 819.12 1192.52 817.16 1181.04 824.52 C 1180.67 814.8 1172.96 806.75 1162.8 805.46 C 1152.64 804.17 1142.98 810.02 1139.93 819.31 C 1138.42 808.52 1127.98 800.95 1116.62 802.39 C 1105.26 803.83 1097.29 813.73 1098.8 824.52 C 1097.08 815.02 1088.4 808.08 1078.25 808.08 C 1068.1 808.08 1059.42 815.02 1057.69 824.52');
                            shape = path;
                        } else if (item.opt.type === 'Topic1') {
                            path.attr('body/refD', 'M 1086.23 916.01 C 1070.15 915.82 1055.06 917.56 1041.84 921.14 C 1033.59 923.02 1026.82 925.76 1021.55 929.33 C 1018.69 931.55 1016.8 934.98 1016.35 938.79 C 1015.89 942.6 1016.91 946.45 1019.15 949.39 C 1022.97 954.55 1030.95 958.8 1042 961.57 C 1050.42 963.67 1059 965.02 1067.64 965.59 C 1074.83 966.12 1082.04 966.14 1089.23 965.63 C 1099.95 965.14 1110.58 963.25 1120.88 960.02 C 1127.26 958.19 1133.24 955.03 1138.47 950.72 C 1140.94 948.87 1142.58 946.01 1142.99 942.82 C 1143.13 938.79 1141.69 935.01 1139.05 932.45 C 1133.71 927.22 1125.74 923.46 1117.57 922.32 C 1099.4 918.88 1080.81 919.49 1062.91 924.13 C 1061.9 924.13 1061.07 925.01 1061.07 926.09 C 1061.07 927.17 1061.9 928.05 1062.91 928.05 C 1072.54 925.46 1082.43 924.14 1092.37 924.13 C 1102.91 923.43 1113.49 924.85 1123.54 928.3 C 1127.58 929.62 1131.33 931.78 1134.57 934.66 C 1136.44 936.43 1137.49 939.03 1137.44 941.75 C 1137.39 944.48 1136.24 947.04 1134.3 948.76 C 1127.67 954.06 1115.95 958.66 1106.51 959.67 C 1084.83 963.28 1062.77 962.54 1041.41 957.5 C 1037.77 956.74 1033.26 954.9 1027.93 952 C 1023.76 949.61 1021.03 946.25 1020.03 942.3 C 1019.42 938.91 1020.66 935.32 1023.2 933.07 C 1026.21 930.34 1031.23 927.77 1038.15 925.41 C 1053.94 920.96 1070.01 917.81 1086.23 916.01');
                            shape = path;
                        } else if (item.opt.type === 'Topic2') {
                            path.attr('body/refD', 'M 849 1144 L 976 1144');
                            shape = path;
                        } else {
                            path.attr('body/refD', item.opt.opt.path);
                            shape = path;
                        }
                        if (item.annotations) {
                            shape.attr('label/annotations', item.annotations);
                        }
                        jointShapes[item.attributes.ID] = shape;
                        if (item.parentShape) {
                            jointShapes[item.parentShape].embed(jointShapes[item.attributes.ID]);
                        }
                        if (item.text.body && item.text.body.text) {
                            item.cell.fill = (item.attributes.FillStyle === '1') ? 'none' : item.cell.fill;
                            item.cell.strokeColor = (item.attributes.LineStyle === '1') ? 'none' : item.cell.strokeColor;
                        }
                        item.cell.fill = (!item.cell.fill || item.cell.fill === 'Themed') ? res.paperOpt.defColor : item.cell.fill;
                        shape.position(item.cell.x, item.cell.y)
                            .resize(width, height)
                            .rotate(rotate)
                            .attr({
                                body: {
                                    fill: item.cell.fill || '#ffffff',
                                    stroke: item.cell.strokeColor || '#000',
                                    strokeWidth: item.cell.strokeWeight || 1,
                                    rx: item.cell.strokeRadius || 0,
                                    ry: item.cell.strokeRadius || 0
                                }
                            });
                        shape.type = item.opt.type;
                        shape.geometry = item.geometry;
                        shape.scratch = item.scratch;
                        graph.addCell(shape);
                    });
                    res.connectors.forEach(function(item) {
                        var link;
                        var shapeBegin = jointShapes[item.connector.begin];
                        var shapeEnd = jointShapes[item.connector.end];
                        var shapeB = shapeBegin.getBBox();
                        var shapeE = shapeEnd.getBBox();
                        shapeB.y = res.paperOpt.height - shapeB.y;
                        shapeE.y = res.paperOpt.height - shapeE.y;
                        var connStartX = item.connector.beginX - shapeB.x - shapeB.width / 2;
                        var connEndX = item.connector.endX - shapeE.x - shapeE.width / 2;
                        var connStartY = shapeB.y - item.connector.beginY - shapeB.height / 2;
                        var connEndY = shapeE.y - item.connector.endY - shapeE.height / 2;
                        var vertices = item.connector.vertices || [];
                        var verticesRes = [];
                        var pX = connStartX + shapeB.x + shapeB.width / 2;
                        var pY = shapeBegin.get('position').y + connStartY + shapeB.height / 2;
                        var vertLength = vertices.length;
                        vertices.forEach(function(p) {
                            verticesRes.push({ x: pX + p.x, y: pY + p.y });
                        });
                        var anchor = { begin: {}, end: {}};
                        if (vertLength > 0) {
                            verticesRes.length -= 1;
                            anchor.begin = {
                                anchor: {
                                    name: 'center',
                                    args: {
                                        rotate: true,
                                        dx: connStartX,
                                        dy: connStartY
                                    }
                                }
                            };
                            anchor.end = {
                                anchor: {
                                    name: 'center',
                                    args: {
                                        rotate: true,
                                        dx: connEndX,
                                        dy: connEndY
                                    }
                                }
                            };
                        }
                        link = new joint.shapes.standard.Link({
                            smooth: false,
                            vertices: verticesRes
                        })
                            .attr(item.connector.line)
                            .source(shapeBegin, anchor.begin)
                            .target(shapeEnd, anchor.end);
                        if (item.cell.strokeRadius) {
                            link.connector('rounded', { radius: item.cell.strokeRadius });
                        }
                        if (item.text.body && item.text.body.text !== '') {
                            link.appendLabel({
                                attrs: {
                                    text: {
                                        text: item.text.body.text
                                    }
                                }
                            });
                        }
                        if (item.attributes.Type === 'Legend') {
                            link.unset('router');
                        }
                        link.geometry = item.geometry;
                        link.connector('jumpover', { size: 4 });
                        graph.addCell(link);
                    });
                    res.legends.forEach(function(legend) {
                        var rect = new joint.shapes.standard.Rectangle();
                        rect.position(legend.x, legend.y);
                        rect.resize(50, 20);
                        rect.attr({
                            body: {
                                fill: 'none',
                                stroke: 'none'
                            },
                            label: {
                                text: legend.body,
                                fill: '#000',
                                textAnchor: 'start'
                            }
                        });
                        rect.addTo(graph);
                    });
                });
            } catch (e) {
                alert(e.toString());
            }
        };
    })(f);
    reader.readAsBinaryString(f);
}
document.querySelector('#export').addEventListener('click', exportToVisio, false);
function exportToVisio() {
    graph.toVisio(graph, paper);
}
function importFromVisio() {
    document.getElementById('import').click();
}