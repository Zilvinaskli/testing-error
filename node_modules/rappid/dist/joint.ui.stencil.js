/*! Rappid v3.0.1 - HTML5 Diagramming Framework

Copyright (c) 2015 client IO

 2019-08-10 


This Source Code Form is subject to the terms of the Rappid License
, v. 2.0. If a copy of the Rappid License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/


this.joint = this.joint || {};
(function (exports, $, core_mjs, PaperScroller_mjs, GridLayout_mjs) {
    'use strict';

    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;

    // JointJS Stencil ui plugin.

    var layoutDefaults = {

        options: function() {
            return {
                columnWidth: this.options.width / 2 - 10,
                columns: 2,
                rowHeight: 80,
                resizeToFit: true,
                dy: 10,
                dx: 10
            };
        },

        /**
         * @param {dia.Graph} graph
         * @param {Object} group Group
         */
        layoutGroup: function(graph, group) {

            var opts = this.options.layout;
            group = group || {};

            if (!GridLayout_mjs.GridLayout) {
                throw new Error('joint.ui.Stencil: joint.layout.GridLayout is not available.');
            }

            GridLayout_mjs.GridLayout.layout(graph, core_mjs.util.assign({}, opts, group.layout));
        }
    };

    var Stencil = core_mjs.mvc.View.extend({

        className: 'stencil',

        events: {
            'click .btn-expand': 'openGroups',
            'click .btn-collapse': 'closeGroups',
            'click .groups-toggle > .group-label': 'openGroups',
            'click .group > .group-label': 'onGroupLabelClick',
            'touchstart .group > .group-label': 'onGroupLabelClick',
            'input .search': 'onSearch',
            'focusin .search': 'pointerFocusIn',
            'focusout .search': 'pointerFocusOut'
        },

        documentEvents: {
            'mousemove': 'onDrag',
            'touchmove': 'onDrag',
            'mouseup': 'onDragEnd',
            'touchend': 'onDragEnd',
            'touchcancel': 'onDragEnd'
        },

        options: {
            width: 200,
            height: 800,
            label: 'Stencil',
            groups: null,
            groupsToggleButtons: false,
            dropAnimation: false,
            search: null,
            layout: null,
            // An instance of Snapline plugin which should display
            // snaplines while dragging an element from the stencil
            snaplines: null,
            // When set to `true` clone views are automatically
            // scaled based on the current paper transformations.
            // Note: this option is ignored when `snaplines` provided.
            scaleClones: false,
            /**
             * @param {dia.Cell} cell
             * @returns {dia.Cell}
             */
            dragStartClone: function(cell) {

                return cell.clone();
            },

            /**
             * @param {dia.Cell} cell
             * @returns {dia.Cell}
             */
            dragEndClone: function(cell) {

                return cell.clone();
            },
            /** @type {function|null} */
            layoutGroup: null,
            // The options passed into the stencil papers.
            // e.g. { elementView: CustomElementView }
            paperOptions: null,

            paperDragOptions: null
        },

        DEFAULT_GROUP: '__default__',

        init: function() {

            this.setPaper(this.options.paperScroller || this.options.paper);

            /** @type {Object.<string, dia.Graph>} */
            this.graphs = {};
            /** @type {Object.<string, dia.Paper>} */
            this.papers = {};
            /** @type {Object.<string, jQuery>} */
            this.$groups = {};

            this.onSearch = core_mjs.util.debounce(this.onSearch, 200);
            // re-delegate the debounced onSearch handler.
            this.delegateEvents();

            this.initializeLayout();
        },

        /**
         * @private
         */
        initializeLayout: function() {

            var layout = this.options.layout;

            if (layout) {

                if (core_mjs.util.isFunction(layout)) {
                    this.layoutGroup = layout;
                } else {
                    this.layoutGroup = layoutDefaults.layoutGroup.bind(this);
                    this.options.layout = core_mjs.util.isObject(layout) ? layout : {};
                    core_mjs.util.defaults(this.options.layout, layoutDefaults.options.call(this));
                }
            }
        },

        /**
         * @public
         * @param {dia.Paper | ui.PaperScroller} paper
         */
        setPaper: function(paper) {

            var options = this.options;

            if (paper instanceof core_mjs.dia.Paper) {

                // Allow Stencil to be initialized with a paper only.
                options.paperScroller = null;
                options.paper = paper;
                options.graph = paper.model;

            } else if (typeof PaperScroller_mjs.PaperScroller === 'function' && paper instanceof PaperScroller_mjs.PaperScroller) {

                // Paper is a PaperScroller
                options.paperScroller = paper;
                options.paper = paper.options.paper;
                options.graph = paper.options.paper.model;

            } else {

                throw new Error('Stencil: paper required');
            }
        },

        /**
         * @private
         * @returns {jQuery}
         */
        renderContent: function() {

            return $('<div/>').addClass('content');
        },

        /**
         * @private
         * @returns {jQuery}
         */
        renderPaperDrag: function() {

            return $('<div/>').addClass('stencil-paper-drag');
        },

        /**
         * @private
         * @returns {jQuery}
         */
        renderSearch: function() {

            return $('<div/>').addClass('search-wrap').append($('<input/>', {
                type: 'search',
                placeholder: 'search'
            }).addClass('search'));
        },

        /**
         * @private
         * @returns {Array.<jQuery>}
         */
        renderToggleAll: function() {

            return [
                $('<div/>').addClass('groups-toggle')
                    .append($('<label/>').addClass('group-label').html(this.options.label))
                    .append($('<button/>', { text: '+' }).addClass('btn btn-expand'))
                    .append($('<button/>', { text: '-' }).addClass('btn btn-collapse'))
            ];
        },

        /**
         * @private
         * @returns {jQuery}
         */
        renderElementsContainer: function() {

            return $('<div/>').addClass('elements');
        },

        /**
         * @private
         * @param {Object} opt
         * @returns {jQuery}
         */
        renderGroup: function(opt) {

            opt = opt || {};

            var $group = $('<div/>')
                .addClass('group')
                .attr('data-name', opt.name)
                .toggleClass('closed', !!opt.closed);

            var $label = $('<h3/>')
                .addClass('group-label')
                .html(opt.label || opt.name);

            var $elements = this.renderElementsContainer();

            return $group.append($label, $elements);
        },

        /**
         * @public
         * @returns {ui.Stencil}
         */
        render: function() {

            var options = this.options;

            this.$content = this.renderContent();
            this.$paperDrag = this.renderPaperDrag();

            this.$el.empty().append(this.$paperDrag, this.$content);

            if (options.search) {
                this.$el.addClass('searchable').prepend(this.renderSearch());
            }

            if (options.groupsToggleButtons) {
                this.$el.addClass('collapsible').prepend(this.renderToggleAll());
            }

            var groups = Object.keys(options.groups || {});
            var hasGroups = groups.length > 0;
            var paperOptions;

            if (options.paperOptions && !core_mjs.util.isFunction(options.paperOptions) && options.paperOptions.model) {
                throw new Error('ui.Stencil: the `paperOptions` has to be a function if there is the property `model` defined.');
            }

            if (hasGroups) {

                // Render as many papers as there are groups.
                var sortedGroups = core_mjs.util.sortBy(groups, function(key) {
                    return this[key].index;
                }.bind(options.groups));

                sortedGroups.forEach(function(name) {

                    var group = this.options.groups[name];

                    var $group = this.$groups[name] = this.renderGroup({
                        name: name,
                        label: group.label,
                        closed: group.closed
                    }).appendTo(this.$content);

                    if (group.paperOptions && group.paperOptions.model) {
                        throw new Error('ui.Stencil: the `model` property is not allowed in the `paperOptions` for the groups.');
                    }

                    paperOptions = core_mjs.util.result(options, 'paperOptions') || {};
                    var groupPaperOption = core_mjs.util.assign({}, paperOptions, group.paperOptions, {
                        el: $group.find('.elements'),
                        model: paperOptions.model || new core_mjs.dia.Graph,
                        width: group.width || options.width,
                        height: group.height || options.height,
                        interactive: false,
                        preventDefaultBlankAction: false
                    });

                    var groupPaper = new core_mjs.dia.Paper(groupPaperOption);

                    this.graphs[name] = groupPaperOption.model;
                    this.papers[name] = groupPaper;

                }, this);

            } else {

                // Groups are not used. Render just one paper for the whole stencil.
                var $elements = this.renderElementsContainer().appendTo(this.$content);

                paperOptions = core_mjs.util.result(options, 'paperOptions') || {};
                var paper = new core_mjs.dia.Paper(core_mjs.util.assign({}, paperOptions, {
                    el: $elements,
                    model: paperOptions.model || new core_mjs.dia.Graph,
                    width: options.width,
                    height: options.height,
                    interactive: false,
                    preventDefaultBlankAction: false
                }));

                // `this.graphs` object contains only one graph in this case that we store under the key `this.DEFAULT_GROUP`.
                this.graphs[this.DEFAULT_GROUP] = paper.model;
                this.papers[this.DEFAULT_GROUP] = paper;
            }

            // Create graph and paper objects for the, temporary, dragging phase.
            // Elements travel the following way when the user drags an element from the stencil and drops
            // it into the main, associated, paper: `[One of the Stencil graphs] -> [_graphDrag] -> [this.options.graph]`.
            paperOptions = core_mjs.util.result(options, 'paperOptions') || {};
            var paperDragOptions = core_mjs.util.result(options, 'paperDragOptions') || {};
            var graphDrag = this._graphDrag = paperDragOptions.model || paperOptions.model || new core_mjs.dia.Graph;

            this._paperDrag = new core_mjs.dia.Paper(core_mjs.util.assign({}, options.paperDragOptions, {
                el: this.$paperDrag,
                width: 1,
                height: 1,
                model: graphDrag
            }));

            this.startListening();

            return this;
        },

        startListening: function() {

            this.stopListening();

            // `cell:pointerdown` on any of the Stencil papers triggers element dragging.
            core_mjs.util.forIn(this.papers, function(paper) {
                this.listenTo(paper, 'cell:pointerdown', this.onDragStart);
            }.bind(this));
        },

        /**
         * @public
         * @param {Array.<dia.Element>|Object.<string, Array.<dia.Element>>} cells Array of cells or hash-map
         * of cells where key is group name.
         * @param {string=} group
         */
        load: function(cells, group) {

            if (Array.isArray(cells)) {

                this.loadGroup(cells, group);

            } else if (core_mjs.util.isObject(cells)) {

                core_mjs.util.forIn(this.options.groups, function(group, name) {
                    if (cells[name]) {
                        this.loadGroup(cells[name], name);
                    }
                }.bind(this));
            }
        },

        /**
         * @public
         * Populate stencil with `cells`. If `group` is passed, only the graph in the named group
         * will be populated
         * @param {Array.<dia.Element>} cells
         * @param {string=} group Mandatory in 'group' mode  - 'options.groups' property is defined
         */
        loadGroup: function(cells, group) {

            var graph = this.getGraph(group);

            graph.resetCells(cells);
            // If height is not defined in neither the global `options.height` or local
            // `height` for this specific group, fit the paper to the content automatically.
            var paperHeight = this.options.height;

            if (group) {
                paperHeight = this.getGroup(group).height;
            }

            if (this.isLayoutEnabled()) {
                this.layoutGroup(graph, this.getGroup(group));
            }

            if (!paperHeight) {
                var paper = this.getPaper(group);
                paper.fitToContent({
                    minWidth: paper.options.width,
                    gridHeight: 1,
                    padding: this.options.paperPadding || 10
                });
            }
        },

        /**
         * @private
         * @returns {boolean}
         */
        isLayoutEnabled: function() {

            return !!(this.options.layout);
        },

        /**
         * @public
         * @param {string=} group
         * @returns {dia.Graph}
         */
        getGraph: function(group) {

            var graph = this.graphs[group || this.DEFAULT_GROUP];
            if (!graph) {
                throw new Error('Stencil: group ' + group + ' does not exist.');
            }

            return graph;
        },

        /**
         * @public
         * @param {string} group
         * @returns {dia.Paper}
         */
        getPaper: function(group) {

            return this.papers[group || this.DEFAULT_GROUP];
        },

        preparePaperForDragging: function(cellView, clientX, clientY) {

            var paperDrag = this._paperDrag;
            var graphDrag = this._graphDrag;

            // Move the .stencil-paper-drag element to the document body so that even though
            // the stencil is set to overflow: hidden or auto, the .stencil-paper-drag will
            // be visible.
            paperDrag.$el.addClass('dragging').appendTo(document.body);

            var clone = this.options.dragStartClone(cellView.model).position(0, 0);

            // Leave some padding so that e.g. the cell shadow or thick border is visible.
            // This workaround can be removed once browsers start supporting getStrokeBBox() (http://www.w3.org/TR/SVG2/types.html#__svg__SVGGraphicsElement__getStrokeBBox).
            var padding = 5;

            var snaplines = this.options.snaplines;
            if (snaplines) {
                padding += snaplines.options.distance;
            }

            if (snaplines || this.options.scaleClones) {
                // Scaling the paper drag, so the clone view match the
                // size of the resulting size as would be placed in the paper.
                var paperScale = this.options.paper.scale();
                paperDrag.scale(paperScale.sx, paperScale.sy);
                padding *= Math.max(paperScale.sx, paperScale.sy);
            } else {
                // restore scale
                paperDrag.scale(1, 1);
            }


            // Make sure the previous clone has been removed before we add a new one.
            this.clearClone();
            if (this.options.dropAnimation) {
                // clear the animation after previous onDropInvalid
                this._paperDrag.$el.stop(true, true);
            }

            graphDrag.resetCells([clone.position(0, 0)]);

            var cloneView = clone.findView(paperDrag);

            // Do not automatically update the cell view while dragging.
            cloneView.stopListening();
            paperDrag.fitToContent({ padding: padding, allowNewOrigin: 'any' });

            var cloneViewBBox = cloneView.getBBox();
            var cloneGeometryBBox = this._cloneGeometryBBox = cloneView.getBBox({ useModelGeometry: true });
            this._cloneViewDeltaOrigin = cloneGeometryBBox.origin().difference(cloneViewBBox.origin());
            this._cloneBBox = clone.getBBox();
            this._clone = clone;
            this._cloneView = cloneView;
            this._paperDragPadding = padding;
            this._paperDragInitialOffset = this.setPaperDragOffset(clientX, clientY);
        },

        setPaperDragOffset: function(clientX, clientY) {

            // Safari uses `document.body.scrollTop` only while Firefox uses `document.documentElement.scrollTop` only.
            // Google Chrome is the winner here as it uses both.
            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;

            // Offset the paper so that the mouse cursor points to the center of the stencil element.
            // Also, store the original coordinates so that we know where to return if `dropAnimation` is enabled.
            var cloneViewDeltaOrigin = this._cloneViewDeltaOrigin;
            var cloneGeometryBBox = this._cloneGeometryBBox;
            var padding = this._paperDragPadding || 5;
            var paperDragOffset = {
                left: clientX - cloneViewDeltaOrigin.x - cloneGeometryBBox.width / 2 - padding,
                top: clientY - cloneViewDeltaOrigin.y - cloneGeometryBBox.height / 2 - padding + scrollTop
            };
            this._paperDrag.$el.offset(paperDragOffset);

            return paperDragOffset;
        },

        setCloneLocalPosition: function(clientX, clientY) {

            var localPosition = this.options.paper.clientToLocalPoint({ x: clientX, y: clientY });
            var cloneBBox = this._cloneBBox;

            localPosition.x -= cloneBBox.width / 2;
            localPosition.y -= cloneBBox.height / 2;

            // We don't want the clone view react on change:position change.
            // But we want processEmbedding to take the clone new position into account,
            // when it looks for models for which the clone can be embedded in.
            this._clone.set('position', localPosition);

            return localPosition;
        },

        onDragStart: function(cellView, evt) {

            evt.preventDefault();
            // Start the dragging batch
            // Batch might contain `add`, `change:parent`, `change:embeds` events.
            this.options.graph.startBatch('stencil-drag');

            this.$el.addClass('dragging');
            this.preparePaperForDragging(cellView, evt.clientX, evt.clientY);

            var localPoint = this.setCloneLocalPosition(evt.clientX, evt.clientY);
            var cloneView = this._cloneView;

            // snaplines
            var snaplines = this.options.snaplines;
            if (snaplines) {

                snaplines.captureCursorOffset(this._cloneView, evt, localPoint.x, localPoint.y);

                cloneView.listenTo(this._clone, 'change:position', this.onCloneSnapped.bind(this));
            }

            this.delegateDocumentEvents(null, evt.data);
        },

        onCloneSnapped: function(clone, position, opt) {
            // Snapline plugin adds `snapped` flag when changing element's position
            if (opt.snapped) {
                var cloneBBox = this._cloneBBox;
                // Set the position of the element to it's original drag paper position
                // and add the snapped offset. This is required by the view `translate` method,
                // which updates the element view position based on the model values.
                clone.position(cloneBBox.x + opt.tx, cloneBBox.y + opt.ty, { silent: true });
                this._cloneView.translate();
                // Restore the element's local position
                clone.set('position', position, { silent: true });

                this._cloneSnapOffset = { x: opt.tx, y: opt.ty };

            } else {

                this._cloneSnapOffset = null;
            }
        },

        onDrag: function(evt) {

            var cloneView = this._cloneView;
            if (cloneView) {
                evt.preventDefault();
                evt = core_mjs.util.normalizeEvent(evt);

                var clientX = evt.clientX;
                var clientY = evt.clientY;
                this.setPaperDragOffset(clientX, clientY);

                var localPoint = this.setCloneLocalPosition(clientX, clientY);

                var embedding = this.options.paper.options.embeddingMode;
                var snaplines = this.options.snaplines;
                var insideValidArea = (embedding || snaplines) && this.insideValidArea({ x: clientX, y: clientY });

                if (embedding) {
                    cloneView.eventData(evt, { paper: this.options.paper });
                    var data = cloneView.eventData(evt);
                    if (insideValidArea) {
                        cloneView.processEmbedding(data);
                    } else {
                        cloneView.clearEmbedding(data);
                    }
                }

                if (snaplines) {
                    if (insideValidArea) {
                        snaplines.snapWhileMoving(cloneView, evt, localPoint.x, localPoint.y);
                    } else {
                        snaplines.hide();
                    }
                }
            }
        },

        onDragEnd: function(evt) {

            var dragClone = this._clone;
            if (dragClone) {

                evt = core_mjs.util.normalizeEvent(evt);

                var cloneView = this._cloneView;
                var cloneBBox = this._cloneBBox;
                var snapOffset = this._cloneSnapOffset;

                var x = cloneBBox.x;
                var y = cloneBBox.y;
                // add the element offset caused by the snaplines
                if (snapOffset) {
                    x += snapOffset.x;
                    y += snapOffset.y;
                }

                // Restore the original clone position if this was changed during the embedding.
                dragClone.position(x, y, { silent: true });

                var cellClone = this.options.dragEndClone(dragClone);
                var dropped = this.drop(cellClone, { x: evt.clientX, y: evt.clientY });

                if (!dropped) {

                    this.onDropInvalid(evt, cellClone);

                } else {

                    this.onDropEnd(dragClone);
                }

                // embedding
                if (this.options.paper.options.embeddingMode && cloneView) {
                    cloneView.eventData(evt, { model: cellClone, paper: this.options.paper });
                    cloneView.finalizeEmbedding(cloneView.eventData(evt));
                }

                // snaplines
                // it's hide on document mouseup by the plugin itself

                // End the dragging batch.
                this.options.graph.stopBatch('stencil-drag');
            }
        },

        onDropEnd: function(cellClone) {

            if (this._clone === cellClone) {

                this.clearClone();

                // Move the .stencil-paper-drag from the document body back to the stencil element.
                this.$el.append(this._paperDrag.$el);

                this.$el.removeClass('dragging');
                this._paperDrag.$el.removeClass('dragging');
            }
        },

        clearClone: function() {

            if (this._clone) {
                this._clone.remove();
                this._clone = null;
                this._cloneView = null;
                this._cloneSnapOffset = null;
                this._paperDragInitialOffset = null;
                this._paperDragPadding = null;
            }
        },

        onDropInvalid: function(evt, cellClone) {

            var clone = this._clone;
            if (clone) {

                evt = core_mjs.util.normalizeEvent(evt);

                cellClone = cellClone || this.options.dragEndClone(clone);

                // Tell the outside world that the drop was not successful.
                this.trigger('drop:invalid', evt, cellClone);

                var dropAnimation = this.options.dropAnimation;
                if (dropAnimation) {

                    var duration = core_mjs.util.isObject(dropAnimation) ? dropAnimation.duration : 150;
                    var easing = core_mjs.util.isObject(dropAnimation) ? dropAnimation.easing : 'swing';

                    // clear the view immediately to prevent user's interaction on the returning shape
                    this._cloneView = null;
                    this._paperDrag.$el.animate(this._paperDragInitialOffset, duration, easing, this.onDropEnd.bind(this, clone));

                } else {

                    this.onDropEnd(clone);
                }
            }
        },

        // Return `true` if the point `p` falls into the valid area for dropping.
        insideValidArea: function(p) {

            var paper = this.options.paper;
            var paperScroller = this.options.paperScroller;

            var stencilArea = this.getDropArea(this.$el);
            var validArea;

            if (!paperScroller) {

                // No paper scroller used. Use entire paper area.
                validArea = this.getDropArea(paper.$el);

            } else if (paperScroller.options.autoResizePaper) {

                // Paper scroller used with auto-resize enabled.
                // We can use the entire paperScroller area for drop.
                validArea = this.getDropArea(paperScroller.$el);

            } else {

                // Paper scroller used with auto-resize disabled.
                // The element can be dropped only into the visible part of the paper.
                var scrollerArea = this.getDropArea(paperScroller.$el);
                var paperArea = this.getDropArea(paper.$el);

                validArea = paperArea.intersect(scrollerArea);
            }

            // Check if the cell is dropped inside the paper but not inside the stencil.
            // Check for the stencil is here because the paper can go "below" the stencil
            // if the paper is larger than the ui.PaperScroller area.
            if (validArea && validArea.containsPoint(p) && !stencilArea.containsPoint(p)) { return true; }

            return false;
        },

        getDropArea: function($el) {

            var position = $el.offset();
            var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
            var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;

            return core_mjs.g.rect({
                x: position.left + parseInt($el.css('border-left-width'), 10) - scrollLeft,
                y: position.top + parseInt($el.css('border-top-width'), 10) - scrollTop,
                width: $el.innerWidth(),
                height: $el.innerHeight()
            });
        },

        drop: function(cell, p) {

            var paper = this.options.paper;
            var graph = this.options.graph;

            // Check if the cell is dropped inside the paper.
            if (this.insideValidArea(p)) {

                var pointTransformed = paper.clientToLocalPoint(p);
                var cellBBox = cell.getBBox();

                pointTransformed.x += cellBBox.x - cellBBox.width / 2;
                pointTransformed.y += cellBBox.y - cellBBox.height / 2;

                // Do not snap to grid if the element was previously snapped to certain position.
                var gridSize = (this._cloneSnapOffset) ? 1 : paper.options.gridSize;

                cell.set('position', {
                    x: core_mjs.g.snapToGrid(pointTransformed.x, gridSize),
                    y: core_mjs.g.snapToGrid(pointTransformed.y, gridSize)
                });

                // `z` level will be set automatically in the `this.graph.addCell()` method.
                // We don't want the cell to have the same `z` level as it had in the temporary paper.
                cell.unset('z');

                graph.addCell(cell, { stencil: this.cid });
                return true;
            }

            return false;
        },

        filter: function(keyword, cellAttributesMap) {

            // We go through each paper.model, filter its cells and watch whether we found a match
            // yet or not.

            var match = Object.keys(this.papers).reduce(function(wasMatch, group) {

                var paper = this.papers[group];
                var groupId = (group === this.DEFAULT_GROUP) ? null : group;

                // an array of cells that matches a search criteria
                var matchedCells = paper.model.getCells().filter(function(cell) {

                    var cellMatch = false;

                    if (core_mjs.util.isFunction(cellAttributesMap)) {
                        // A: search is defined as a function
                        cellMatch = cellAttributesMap.call(this, cell, keyword, groupId, this);
                    } else {
                        // B: search is defined as an attribute map
                        // SmartCase
                        // a searching mode when the keyword consists of lowercase only
                        // e.g 'keyword' matches 'Keyword' but not other way round
                        cellMatch = this.isCellMatched(cell, keyword, cellAttributesMap, keyword.toLowerCase() !== keyword);
                    }

                    // each element that does not match a search has 'unmatched' css class
                    var cellView = paper.findViewByModel(cell);
                    if (cellView) {
                        cellView.vel.toggleClass('unmatched', !cellMatch);
                    }

                    return cellMatch;

                }.bind(this));

                var isMatch = !core_mjs.util.isEmpty(matchedCells);

                // create a graph contains only filtered elements.
                var options = this.options;
                var paperOptions = core_mjs.util.result(options, 'paperOptions') || {};
                var graph = paperOptions.model || new core_mjs.dia.Graph;
                var filteredGraph = (graph).resetCells(matchedCells);

                // let the outside world know that the group was filtered
                this.trigger('filter', filteredGraph, group, keyword);

                if (this.isLayoutEnabled()) {
                    this.layoutGroup(filteredGraph, this.getGroup(group));
                }

                if (this.$groups[group]) {
                    // add 'unmatched' class when filter matches no elements in the group
                    this.$groups[group].toggleClass('unmatched', !isMatch);
                }

                paper.fitToContent({
                    gridWidth: 1,
                    gridHeight: 1,
                    padding: options.paperPadding || 10
                });

                return wasMatch || isMatch;

            }.bind(this), false);

            // When no match found we add 'not-found' class on the stencil element
            this.$el.toggleClass('not-found', !match);
        },

        isCellMatched: function(cell, keyword, cellAttributesMap, caseSensitive) {

            if (!keyword) { return true; }

            return Object.keys(cellAttributesMap).some(function(type) {
                var paths = cellAttributesMap[type];

                if (type != '*' && cell.get('type') != type) {
                    // type is not universal and doesn't match the current cell
                    return false;
                }

                // find out if any of specific cell attributes matches a search criteria
                var attributeMatch = paths.some(function(path) {

                    var value = core_mjs.util.getByPath(cell.attributes, path, '/');

                    if (value === undefined || value === null) {
                        // if value undefined than current attribute doesn't match
                        return false;
                    }

                    // convert values to string first (e.g value could be a number)
                    value = value.toString();

                    if (!caseSensitive) {
                        value = value.toLowerCase();
                    }

                    return value.indexOf(keyword) >= 0;
                });

                return attributeMatch;
            });
        },
        /**
         * @private
         * @param {string} name
         * @returns {Object}
         */
        getGroup: function(name) {

            return this.options.groups && this.options.groups[name] || {};
        },

        /**
         * @private
         * @param {jQuery.Event} evt
         */
        onSearch: function(evt) {

            this.filter(evt.target.value, this.options.search);
        },

        /**
         * @private
         */
        pointerFocusIn: function() {
            this.$el.addClass('is-focused');
        },

        /**
         * @private
         */
        pointerFocusOut: function() {
            this.$el.removeClass('is-focused');
        },

        /**
         * @private
         * @param {jQuery.Event} evt
         */
        onGroupLabelClick: function(evt) {

            // Prevent touch devices not to handle this event twice.
            // Note that both touchstart and click (evt mousedown) are fired.
            if (evt.type === 'touchstart') {
                this._groupLabelClicked = true;
            } else if (this._groupLabelClicked && evt.type === 'click') {
                this._groupLabelClicked = false;
                return;
            }

            var $group = $(evt.target).closest('.group');
            this.toggleGroup($group.data('name'));
        },

        /**
         * @public
         * @param {string} name
         */
        toggleGroup: function(name) {
            if (this.isGroupOpen(name)) {
                this.closeGroup(name);
            } else {
                this.openGroup(name);
            }
        },

        /**
         * @public
         * @param {string} name
         */
        closeGroup: function(name) {
            var $group = this.$groups[name];
            if (!$group || !this.isGroupOpen(name)) { return; }
            this.trigger('group:close', name);
            $group.addClass('closed');
        },

        /**
         * @public
         * @param {string} name
         */
        openGroup: function(name) {
            var $group = this.$groups[name];
            if (!$group || this.isGroupOpen(name)) { return; }
            this.trigger('group:open', name);
            $group.removeClass('closed');
        },

        /**
         * @public
         * @param {string} name
         */
        isGroupOpen: function(name) {
            var $group = this.$groups[name];
            if (!$group) { return false; }
            return !$group.hasClass('closed');
        },

        /**
         * @public
         */
        closeGroups: function() {
            Object.keys(this.$groups).forEach(function(group) {
                this.closeGroup(group);
            }, this);
        },

        /**
         * @public
         */
        openGroups: function() {
            Object.keys(this.$groups).forEach(function(group) {
                this.openGroup(group);
            }, this);
        },

        /**
         * @private
         */
        onRemove: function() {

            core_mjs.util.invoke(this.papers, 'remove');
            this.papers = {};

            if (this._paperDrag) {
                this._paperDrag.remove();
                this._paperDrag = null;
            }

            this.undelegateDocumentEvents();
        }
    });

    exports.Stencil = Stencil;

}(this.joint.ui = this.joint.ui || {}, $, joint, joint.ui, joint.layout));
