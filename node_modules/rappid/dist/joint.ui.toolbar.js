/*! Rappid v3.0.1 - HTML5 Diagramming Framework

Copyright (c) 2015 client IO

 2019-08-10 


This Source Code Form is subject to the terms of the Rappid License
, v. 2.0. If a copy of the Rappid License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/


this.joint = this.joint || {};
(function (exports, core_mjs, $, SelectBox_mjs, SelectButtonGroup_mjs) {
    'use strict';

    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;

    var Widget = core_mjs.mvc.View.extend({

        className: 'widget',
        /** @type {Array.<string>} List of mandatory references, widget cannot be created if any of the reference from list
         * is not defined in options */
        references: [],

        constructor: function(options, refs) {

            this.availableReferences = refs || {};
            core_mjs.mvc.View.prototype.constructor.call(this, options);
        },
        /**
         * @private
         * Apply attributes data onto widget elements.
         * @param {Object.<string, Object>} attrs
         * @returns {jQuery}
         */
        updateAttrs: function(attrs) {

            core_mjs.util.setAttributesBySelector(this.$el, attrs);
        },

        /**
         * @protected
         * Override in specific widget.
         */
        bindEvents: function() {

        },

        /**
         * @private
         */
        validateReferences: function() {
            var refs = this.references || [];
            var ret = [];

            refs.forEach(function(ref) {

                if (this.availableReferences[ref] === undefined) {
                    ret.push(ref);
                }

            }, this);

            return ret;
        },

        /**
         * @protected
         * @param {string} name
         * @returns {*}
         */
        getReference: function(name) {
            return this.availableReferences[name];
        },

        /**
         * @protected
         * @returns {Array.<*>}
         */
        getReferences: function() {
            return this.availableReferences;
        }

    });

    var checkbox = Widget.extend({

        tagName: 'label',
        events: {
            'change .input': 'onChange',
            'mousedown': 'pointerdown',
            'touchstart': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',
            'click': 'pointerclick'
        },
        documentEvents: {
            'mouseup': 'pointerup',
            'touchend': 'pointerup'
        },

        init: function() {
            core_mjs.util.bindAll(this, 'pointerup');
        },

        render: function() {

            var opt = this.options;

            var $label = $('<span/>').text(opt.label || '');
            this.$input = $('<input/>', { type: 'checkbox', 'class': 'input' }).prop('checked', !!opt.value);
            this.$span = $('<span/>');

            this.$el.append([$label, this.$input, this.$span]);

            return this;
        },

        onChange: function(evt) {
            this.trigger('change', !!evt.target.checked, evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.addClass('is-in-action');
            this.trigger('pointerdown', evt);
            this.delegateDocumentEvents();
        },

        pointerclick: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.undelegateDocumentEvents();
            this.trigger('pointerup', evt);
            this.$el.removeClass('is-in-action');
            if (evt.type === 'touchend') {
                this.$input.trigger('click');
                evt.preventDefault();
            }
        }
    });

    var toggle = Widget.extend({

        tagName: 'label',
        events: {
            'change input.toggle': 'onChange',
            'click input.toggle': 'pointerclick',
            'mousedown': 'pointerdown',
            'touchstart': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',

        },
        documentEvents: {
            'mouseup': 'pointerup',
            'touchend': 'pointerup'
        },

        init: function() {
            core_mjs.util.bindAll(this, 'pointerup');
        },

        render: function() {

            var opt = this.options;

            var $label = $('<span/>').text(opt.label || '');
            var $button = $('<span><i/></span>');
            this.$input = $('<input/>', { type: 'checkbox', class: 'toggle' }).prop('checked', !!opt.value);
            var $wrapper = $('<div/>').addClass(opt.type);

            this.$el.append([$label, $wrapper.append(this.$input, $button)]);

            return this;
        },

        onChange: function(evt) {
            this.trigger('change', !!evt.target.checked, evt);
        },

        pointerclick: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.addClass('is-in-action');
            this.trigger('pointerdown', evt);
            this.delegateDocumentEvents();
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.undelegateDocumentEvents();
            this.$el.removeClass('is-in-action');
            this.trigger('pointerup', evt);

            if (evt.type === 'touchend') {
                this.$input.trigger('click');
                evt.preventDefault();
            }
        }
    });

    var separator = Widget.extend({

        render: function() {

            if (this.options.width) {
                this.$el.css({ width: this.options.width });
            }

            return this;
        }
    });

    var label = Widget.extend({

        tagName: 'label',

        render: function() {

            this.$el.text(this.options.text);

            return this;
        }
    });

    var range = Widget.extend({

        events: {
            'change .input': 'onChange',
            'input .input': 'onChange'
        },

        render: function() {

            var opt = this.options;
            var $units;

            this.$output = $('<output/>').text(opt.value);
            $units = $('<span/>').addClass('units').text(opt.unit);
            this.$input = $('<input/>', {
                type: 'range',
                name: opt.type,
                min: opt.min,
                max: opt.max,
                step: opt.step,
                'class': 'input'
            }).val(opt.value);

            this.$el.append([this.$input, this.$output, $units]);

            return this;
        },

        onChange: function(evt) {

            var value = parseInt(this.$input.val(), 10);
            if (value === this.currentValue) {
                return;
            }

            this.currentValue = value;
            this.$output.text(value);
            this.trigger('change', value, evt);
        },

        setValue: function(value) {
            this.$input.val(value);
            this.$input.trigger('change');
        }
    });

    var selectBox = Widget.extend({

        render: function() {

            var selectBoxOptions = core_mjs.util.omit(this.options, 'type', 'group', 'index');

            this.selectBox = new SelectBox_mjs.SelectBox(selectBoxOptions);
            this.selectBox.render().$el.appendTo(this.el);

            return this;
        },

        bindEvents: function() {
            this.selectBox.on('all', this.trigger, this);
        }
    });

    var button = Widget.extend({

        events: {
            'mousedown': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',
            'touchstart': 'pointerdown',
            'click': 'pointerclick'
        },
        tagName: 'button',

        render: function() {

            var opt = this.options;

            this.$el.text(opt.text);

            return this;
        },

        pointerclick: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerdown', evt);
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerup', evt);

            if (evt.type === 'touchend') {
                this.$el.trigger('click');
                evt.preventDefault();
            }
        }
    });

    var inputText = Widget.extend({

        events: {
            'mousedown': 'pointerdown',
            'touchstart': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',
            'click': 'pointerclick',
            'focusin': 'pointerfocusin',
            'focusout': 'pointerfocusout'
        },
        tagName: 'div',

        render: function() {

            var opt = this.options;

            this.$label = $('<label/>').text(opt.label);
            this.$text = $('<input/>', {
                type: 'text',
                'class': 'input'
            }).val(opt.value);

            this.$input = $('<div/>').addClass('input-wrapper').append(this.$text);

            this.$el.append([this.$label, this.$input]);

            return this;
        },

        pointerclick: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerdown', evt);
            if (evt.type === 'touchstart') {
                this.$text.trigger('focus');
            }
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerup', evt);
            if (evt.type === 'touchend') {
                this.$text.trigger('click');
                evt.preventDefault();
            }
        },

        pointerfocusin: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.addClass('is-focused');
            this.trigger('pointerfocusin', evt);
        },

        pointerfocusout: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.removeClass('is-focused');
            this.trigger('pointerfocusout', evt);
        }
    });

    var inputNumber = Widget.extend({

        events: {
            'mousedown': 'pointerdown',
            'touchstart': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',
            'click': 'pointerclick',
            'focusin': 'pointerfocusin',
            'focusout': 'pointerfocusout'
        },
        tagName: 'div',

        render: function() {

            var opt = this.options;

            this.$label = $('<label/>').text(opt.label);
            this.$number = $('<input/>', {
                type: 'number',
                'class': 'number',
                max: opt.max,
                min: opt.min
            }).val(opt.value);
            this.$input = $('<div/>').addClass('input-wrapper').append(this.$number);

            this.$el.append([this.$label, this.$input]);

            return this;
        },

        pointerclick: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerdown', evt);
            if (evt.type === 'touchstart') {
                this.$number.trigger('focus');
            }
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerup', evt);
            if (evt.type === 'touchend') {
                this.$number.trigger('click');
                evt.preventDefault();
            }
        },

        pointerfocusin: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.addClass('is-focused');
            this.trigger('pointerfocusin', evt);
        },

        pointerfocusout: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.removeClass('is-focused');
            this.trigger('pointerfocusout', evt);
        }
    });

    var textarea = Widget.extend({

        events: {
            'mousedown': 'pointerdown',
            'touchstart': 'pointerdown',
            'mouseup': 'pointerup',
            'touchend': 'pointerup',
            'click': 'pointerclick',
            'focusin': 'pointerfocusin',
            'focusout': 'pointerfocusout'
        },
        tagName: 'div',

        render: function() {

            var opt = this.options;

            this.$label = $('<label/>').text(opt.label);
            this.$textarea = $('<textarea/>', {
                'class': 'textarea'
            }).text(opt.value);
            this.$input = $('<div/>').addClass('input-wrapper').append(this.$textarea);

            this.$el.append([this.$label, this.$input]);

            return this;
        },

        pointerclick: function(evt) {
            evt.preventDefault();
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerclick', evt);
        },

        pointerdown: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerdown', evt);
            if (evt.type === 'touchstart') {
                this.$textarea.focus();
            }
        },

        pointerup: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.trigger('pointerup', evt);
            if (evt.type === 'touchend') {
                this.$textarea.trigger('click');
                evt.preventDefault();
            }
        },

        pointerfocusin: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.addClass('is-focused');
            this.trigger('pointerfocusin', evt);
        },

        pointerfocusout: function(evt) {
            evt = core_mjs.util.normalizeEvent(evt);
            this.$el.removeClass('is-focused');
            this.trigger('pointerfocusout', evt);
        }
    });

    var selectButtonGroup = Widget.extend({

        render: function() {

            var selectButtonGroupOptions = core_mjs.util.omit(this.options, 'type', 'group', 'index');

            this.selectButtonGroup = new SelectButtonGroup_mjs.SelectButtonGroup(selectButtonGroupOptions);
            this.selectButtonGroup.render().$el.appendTo(this.el);

            return this;
        },

        bindEvents: function() {
            this.selectButtonGroup.on('all', this.trigger, this);
        }
    });

    var zoomIn = button.extend({

        references: ['paperScroller'],
        options: {
            min: 0.2,
            max: 5,
            step: 0.2
        },

        pointerdown: function(evt) {

            var opt = this.options;

            this.getReferences().paperScroller.zoom(opt.step, { max: opt.max, grid: opt.step });
            button.prototype.pointerdown.call(this, evt);
        }
    });

    var zoomOut = button.extend({

        references: ['paperScroller'],
        options: {
            min: 0.2,
            max: 5,
            step: 0.2
        },

        pointerdown: function(evt) {

            var opt = this.options;

            this.getReferences().paperScroller.zoom(-opt.step, { min: opt.min, grid: opt.step });
            button.prototype.pointerdown.call(this, evt);
        }
    });

    var zoomToFit = button.extend({

        references: ['paperScroller'],
        options: {
            min: 0.2,
            max: 5,
            step: 0.2
        },

        pointerdown: function(evt) {

            var opt = this.options;

            this.getReferences().paperScroller.zoomToFit({
                padding: 20,
                scaleGrid: opt.step,
                minScale: opt.min,
                maxScale: opt.max
            });
            button.prototype.pointerdown.call(this, evt);
        }
    });

    var zoomSlider = range.extend({

        references: ['paperScroller'],
        options: {
            min: 20,
            max: 500,
            step: 20,
            value: 100,
            unit: ' %'
        },

        bindEvents: function() {

            this.on('change', function(value) {
                this.getReferences().paperScroller.zoom(value / 100, { absolute: true, grid: this.options.step / 100 });
            }, this);

            this.getReferences().paperScroller.options.paper.on('scale', function(value) {
                this.setValue(Math.floor(value * 100));
            }, this);
        }
    });

    var undo = button.extend({

        references: ['commandManager'],

        pointerclick: function() {
            this.getReferences().commandManager.undo();
        }
    });

    var redo = button.extend({

        references: ['commandManager'],

        pointerclick: function() {
            this.getReferences().commandManager.redo();
        }
    });

    var fullscreen = button.extend({

        onRender: function() {
            var target = this.target = $(this.options.target)[0];
            if (target && !$.contains(window.top.document, target)) {
                // The fullscreen feature is available only if the target is not displayed within an iframe.
                this.$el.hide();
            }
        },

        pointerclick: function() {
            core_mjs.util.toggleFullScreen(this.target);
        }
    });

    var widgets = /*#__PURE__*/Object.freeze({
        checkbox: checkbox,
        toggle: toggle,
        separator: separator,
        label: label,
        range: range,
        selectBox: selectBox,
        button: button,
        inputText: inputText,
        inputNumber: inputNumber,
        textarea: textarea,
        selectButtonGroup: selectButtonGroup,
        zoomIn: zoomIn,
        zoomOut: zoomOut,
        zoomToFit: zoomToFit,
        zoomSlider: zoomSlider,
        undo: undo,
        redo: redo,
        fullscreen: fullscreen
    });

    Widget.create = function cre(opt, refs) {

        var type = core_mjs.util.camelCase(core_mjs.util.isString(opt) ? opt : opt.type);

        if (!core_mjs.util.isFunction(widgets[type])) {
            throw new Error('Widget: unable to find widget: "' + type + '"');
        }

        var widget = new widgets[type](opt, refs);

        var invalidRefs = widget.validateReferences(refs);
        if (invalidRefs.length > 0) {
            throw new Error('Widget: "' + type + '" missing dependency: ' + invalidRefs.join(', '));
        }

        widget.render();
        widget.updateAttrs(opt.attrs);
        widget.bindEvents();
        widget.$el.attr('data-type', type);

        if (opt.name) {
            widget.$el.attr('data-name', opt.name);
        }

        return widget;
    };

    /**
     * @typedef {{items: Array.<Object>, group: Object}} GroupedItems
     */
    var Toolbar = core_mjs.mvc.View.extend({

        options: {
            /*
             tools: [
                {group: 'groupName'}
             ],
             groups: {
                'name': {
                    index: number,
                    align: 'left' | 'right'
                }

             }
             references: {}
             */
        },
        align: ['left', 'right'],
        className: 'toolbar',
        defaultGroup: 'default',
        widgets: [],
        groupViews: [],

        init: function() {

            this.tools = core_mjs.util.toArray(this.options.tools);
            this.groups = this.options.groups || {};
        },

        /**
         * @public
         * @param {string} name
         * @returns {Array.<ui.Widget>}
         */
        getWidgetByName: function(name) {

            return this.widgets.find(function(item) {
                return item.options.name === name;
            });
        },

        /**
         * @public
         * @returns {Array.<ui.Widget>}
         */
        getWidgets: function() {

            return this.widgets;
        },

        /**
         * @private
         * @typedef {{items: Array.<Object>, group: Object}} GroupedItems
         * @returns {Array.<[string, GroupedItems]>}
         */
        groupsWithItemsPairs: function() {

            var groupedItems = {};

            this.tools.forEach(function(item) {

                var group = item.group || this.defaultGroup;
                groupedItems[group] = groupedItems[group] || { items: [], group: {}};
                groupedItems[group].items.push(item);
                groupedItems[group].group = this.groups[group] || {};

            }, this);

            var keys = Object.keys(groupedItems);

            var pairs = [];
            for (var i = 0, n = keys.length; i < n; i++) {
                var key = keys[i];
                pairs.push([key, groupedItems[key]]);
            }

            var byIndex = core_mjs.util.sortBy(pairs, function(pair) {
                return pair[1].group.index;
            });

            return core_mjs.util.sortBy(byIndex, function(pair) {
                return pair[1].group.align || 'left';
            });
        },

        /**
         * @public
         * @returns {ui.Toolbar}
         */
        render: function() {

            var sortedGroups = this.groupsWithItemsPairs();
            var firstAlignRight = false;

            sortedGroups.forEach(function(groupArray) {

                var name = groupArray[0];
                var grouped = groupArray[1];
                var $group = this.renderGroup(name, grouped);

                if (!firstAlignRight && grouped.group.align && grouped.group.align === 'right') {
                    firstAlignRight = true;
                    $group.addClass('group-first');
                }

                $group.appendTo(this.el);

            }, this);

            return this;
        },

        /**
         * @private
         * @param {string} name
         * @param {GroupedItems} grouped
         * @returns {jQuery}
         */
        renderGroup: function(name, grouped) {

            var groupView = new ToolbarGroupView({
                name: name,
                align: grouped.group.align,
                items: grouped.items,
                references: this.options.references
            });

            this.groupViews.push(groupView);

            groupView.on('all', function() {
                this.trigger.apply(this, arguments);
            }.bind(this));

            groupView.render();

            this.widgets = this.widgets.concat(groupView.widgets);

            return groupView.$el;
        },

        onRemove: function() {

            core_mjs.util.invoke(this.groupViews, 'off');
            core_mjs.util.invoke(this.groupViews, 'remove');
        }
    });

    var ToolbarGroupView = core_mjs.mvc.View.extend({

        className: 'toolbar-group',

        init: function() {

            this.widgets = [];
        },

        onRender: function() {

            this.$el.attr('data-group', this.options.name);
            this.$el.addClass(this.options.align);
            this.renderItems();
        },

        renderItems: function() {

            core_mjs.util.toArray(this.options.items).forEach(function(item) {
                var widget = this.createWidget(item);
                this.$el.append(widget.$el);
            }, this);
        },

        createWidget: function(item) {

            var widget = Widget.create(item, this.options.references);
            widget.on('all', function(eventName) {
                var data = Array.prototype.slice.call(arguments, 1);
                this.trigger.apply(this, [item.name + ':' + eventName].concat(data));
            }.bind(this));
            this.widgets.push(widget);
            return widget;
        },

        onRemove: function() {

            core_mjs.util.invoke(this.widgets, 'off');
            core_mjs.util.invoke(this.widgets, 'remove');
        }
    });

    exports.Toolbar = Toolbar;

}(this.joint.ui = this.joint.ui || {}, joint, $, joint.ui, joint.ui));
