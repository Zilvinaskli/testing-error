/*! Rappid v3.0.1 - HTML5 Diagramming Framework

Copyright (c) 2015 client IO

 2019-08-10 


This Source Code Form is subject to the terms of the Rappid License
, v. 2.0. If a copy of the Rappid License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/


this.joint = this.joint || {};
(function (exports, $, core_mjs) {
    'use strict';

    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;

    // Tree Graph Layout View.

    var TreeLayoutView = core_mjs.mvc.View.extend({

        MINIMAL_PREVIEW_SIZE: 10,
        className: 'tree-layout',

        documentEvents: {
            'mousemove': 'onPointermove',
            'touchmove': 'onPointermove',
            'mouseup': 'onPointerup',
            'touchend': 'onPointerup'
        },

        options: {

            // SVG attributes for the child and parent preview SVG elements.
            previewAttrs: {
                parent: { rx: 2, ry: 2 }
            },

            // Compute the bounding boxes for elements either from the DOM or based
            // on the model size.
            useModelGeometry: false,

            // clone method used when an element preview is created.
            clone: function(cell) {
                return cell.clone();
            },

            // Specify what elements can be interacted with.
            // e.g function(element) { return !element.get('disabled'); }
            canInteract: function() {
                return true;
            },

            // Specify what elements can be connected to the element being dragged.
            // e.g function(element, candidate, treeLayoutView) { return candidate.get('canHaveChildren') }
            validateConnection: null,

            paperConstructor: core_mjs.dia.Paper,

            paperOptions: null,

            // A custom function for reconnecting elements
            // function(elements, parentElement, siblingRank, direction, treeLayoutView) {}
            reconnectElements: null,

            // A custom function for translating elements
            // function(elements, x, y, treeLayoutView) {}
            translateElements: null
        },

        init: function() {

            this.toggleDefaultInteraction(false);
            this.startListening();
            this.render();
            this.onSetTheme(null, this.theme);
        },

        // @public
        startListening: function() {

            var paper = this.options.paper;

            this.listenTo(paper, 'element:pointerdown', this.canInteract(this.onPointerdown));
        },

        // @public
        // Enable/Disable the default paper interactions.
        toggleDefaultInteraction: function(interactive) {

            this.options.paper.setInteractivity(interactive);
        },

        render: function() {

            var paper = this.options.paper;

            this.$activeBox = $('<div>')
                .addClass('tree-layout-box active hidden')
                .appendTo(this.el);

            var paperOptions = core_mjs.util.assign({}, this.options.paperOptions, {
                interactive: false,
                width: '100%',
                height: '100%'
            });
            this.draggingPaper = new (this.options.paperConstructor)(paperOptions);
            this.draggingPaper.undelegateEvents();

            this.$translateBox = $('<div>')
                .addClass('tree-layout-box translate hidden')
                .append(this.draggingPaper.render().el)
                .appendTo(this.el);

            this.$mask = $('<div>').addClass('tree-layout-mask');

            this.svgViewport = core_mjs.V(paper.cells);
            this.svgPreviewChild = core_mjs.V(this.renderChildPreview())
                .attr(this.options.previewAttrs.child || {})
                .addClass('tree-layout-preview child');
            this.svgPreviewConnection = core_mjs.V(this.renderConnectionPreview())
                .attr(this.options.previewAttrs.link || {})
                .addClass('tree-layout-preview link');
            this.svgPreviewParent = core_mjs.V(this.renderParentPreview())
                .attr(this.options.previewAttrs.parent || {})
                .addClass('tree-layout-preview parent');
            this.svgPreview = core_mjs.V('g').addClass('tree-layout-preview-group').append([
                this.svgPreviewConnection,
                this.svgPreviewParent,
                this.svgPreviewChild
            ]);

            this.$el.appendTo(paper.el);

            return this;
        },

        renderChildPreview: function() {
            return core_mjs.V('circle');
        },

        renderParentPreview: function() {
            return core_mjs.V('rect');
        },

        renderConnectionPreview: function() {
            return core_mjs.V('path');
        },

        onSetTheme: function(oldTheme, newTheme) {

            var $elsWithThemeClass = [
                this.svgPreview,
                this.$mask
            ];

            $elsWithThemeClass.forEach(function($elWithThemeClass) {

                if ($elWithThemeClass) {

                    if (oldTheme) {
                        $elWithThemeClass.removeClass(this.themeClassNamePrefix + oldTheme);
                    }

                    $elWithThemeClass.addClass(this.themeClassNamePrefix + newTheme);
                }
            }, this);
        },

        onRemove: function() {

            this.svgPreview.remove();
        },

        toggleDropping: function(state) {

            // allows setting various cursor on the paper
            this.$mask.toggleClass('dropping-not-allowed', !state);
            // allows coloring of the translate box based on the state
            this.$translateBox.toggleClass('no-drop', !state);
        },

        canDrop: function() {

            return this.isActive() && !this.$translateBox.hasClass('no-drop');
        },

        isActive: function() {

            return !this.$translateBox.hasClass('hidden');
        },

        _startDrag: function(elements, x, y) {

            var paper = this.options.paper;

            this.$mask.appendTo(paper.el);
            this.toggleDropping(false);

            this.ctm = paper.matrix();

            var element = elements[0];
            var elementView = element.findView(paper);
            var bbox = elementView.getBBox({ useModelGeometry: this.options.useModelGeometry });

            // showing box around active element
            this.updateBox(this.$translateBox, core_mjs.util.defaults({ x: x, y: y }, bbox));
            this.updateBox(this.$activeBox, bbox);

            this.$activeBox.removeClass('hidden');
            this.$translateBox.removeClass('hidden');

            this.prepareDraggingPaper(element);
        },

        updateBox: function($box, bbox) {

            $box.css({
                width: bbox.width,
                height: bbox.height,
                left: bbox.x,
                top: bbox.y
            });
        },

        positionTranslateBox: function(position) {

            var transformedPosition = core_mjs.V.transformPoint(position, this.ctm);

            this.$translateBox.css({
                left: transformedPosition.x,
                top: transformedPosition.y
            });
        },

        prepareDraggingPaper: function(draggedElement) {

            var clone = this.options.clone(draggedElement).position(0, 0);

            // Zoom the dragging paper the same way as the main paper.
            this.draggingPaper.scale(this.ctm.a, this.ctm.d);
            this.draggingPaper.model.resetCells([clone]);
        },

        _doDrag: function(elements, x, y) {

            var layout = this.model;
            var coordinates = { x: x, y: y };
            var rootLayoutArea;
            var layoutArea;

            if (this.candidate) {
                this.candidate = null;
                this.hidePreview();
            }

            this.positionTranslateBox(coordinates);

            rootLayoutArea = layout.getMinimalRootAreaByPoint(coordinates);
            if (rootLayoutArea) {
                layoutArea = rootLayoutArea.findMinimalAreaByPoint(coordinates, {
                    expandBy: Math.min(layout.get('siblingGap'), layout.get('gap')) / 2
                });
            }

            if (layoutArea) {

                var direction = this.findDirection(layoutArea, coordinates);
                var siblings = layoutArea.getLayoutSiblings(direction);
                var siblingRank = siblings.getSiblingRankByPoint(coordinates);

                var isConnectionValid = core_mjs.util.toArray(elements).every(function(item) {
                    return this.isConnectionValid(item, siblings, siblingRank);
                }, this);
                if (isConnectionValid) {

                    this.candidate = {
                        id: layoutArea.root.id,
                        direction: direction,
                        siblingRank: siblingRank
                    };

                    this.updatePreview(siblings, siblingRank);
                    this.showPreview();

                    this.toggleDropping(true);

                } else {
                    this.toggleDropping(false);
                }

            } else {

                this.toggleDropping(true);
            }
        },

        _finishDrag: function(elements, x, y) {

            this.$mask.remove().removeClass('dropping-not-allowed');

            var candidate = this.candidate;
            var options = this.options;
            if (candidate) {
                // Connect Elements
                var reconnectElementsFn = options.reconnectElements;
                if (typeof reconnectElementsFn === 'function') {
                    reconnectElementsFn.apply(this, [
                        elements,
                        options.paper.getModelById(candidate.id),
                        candidate.siblingRank,
                        candidate.direction,
                        this
                    ]);
                } else {
                    this.reconnectElements(elements, candidate);
                }
                this.candidate = null;
            } else if (this.canDrop()) {
                // Disconnect or Translate Elements
                var translateElementsFn = options.translateElements;
                if (typeof translateElementsFn === 'function') {
                    translateElementsFn.call(this, elements, x, y, this);
                } else {
                    this.translateElements(elements, x, y);
                }
            }

            this.$activeBox.addClass('hidden');
            this.$translateBox.addClass('hidden');

            this.hidePreview();
        },

        reconnectElement: function(element, candidate) {

            var siblingRank = candidate.siblingRank + 0.5;
            var opt = {
                direction: candidate.direction,
                siblingRank: siblingRank,
                ui: true
            };

            var canReconnect = this.model.reconnectElement(element, candidate.id, opt);
            if (!canReconnect) {

                var paper = this.options.paper;
                var link = paper.getDefaultLink(element.findView(paper));

                link.set({ source: { id: candidate.id }, target: { id: element.id }});
                link.addTo(paper.model, opt);

                this.model.changeSiblingRank(element, siblingRank, opt);
                this.model.changeDirection(element, candidate.direction, opt);

                var prevDirection = this.model.getAttribute(element, 'direction');

                this.model.updateDirections(element, [prevDirection, candidate.direction], opt);
            }
        },

        reconnectElements: function(elements, candidate) {

            elements.forEach(function(element) {
                this.reconnectElement(element, candidate);
            }, this);
            this.layout();
        },

        translateElement: function(element, x, y) {

            var inboundLinks = this.model.graph.getConnectedLinks(element, { inbound: true });

            core_mjs.util.invoke(inboundLinks, 'remove');

            var elementSize = element.get('size');

            element.set('position', {
                x: x - elementSize.width / 2,
                y: y - elementSize.height / 2
            }, { ui: true });
        },

        translateElements: function(elements, x, y) {

            elements.forEach(function(element) {
                this.translateElement(element, x, y);
            }, this);
            this.layout();
        },

        layout: function() {
            this.model.layout({ ui: true, treeLayoutView: this.cid });
        },

        updatePreview: function(siblings, siblingRank) {

            var parent = siblings.parentArea.root;
            var childWidth = Math.max(this.model.get('siblingGap') / 2, this.MINIMAL_PREVIEW_SIZE);
            var childSize = { width: childWidth, height: childWidth };
            var childPosition = siblings.getNeighborPointFromRank(siblingRank);
            var points = siblings.getConnectionPoints(childPosition, { ignoreSiblings: true });
            var parentPoint = siblings.getParentConnectionPoint();
            var childPoint = siblings.getChildConnectionPoint(childPosition, childSize);

            this.updateParentPreview(parent.position(), parent.size(), parent);
            this.updateChildPreview(childPosition, childSize);
            this.updateConnectionPreview(parentPoint, childPoint, points);
        },

        showPreview: function() {

            this.svgViewport.append(this.svgPreview);
        },

        hidePreview: function() {

            this.svgPreview.remove();
        },

        updateParentPreview: function(position, size) {

            this.svgPreviewParent.attr({
                x: position.x,
                y: position.y,
                width: size.width,
                height: size.height
            });
        },

        updateChildPreview: function(position, size) {

            this.svgPreviewChild.attr({
                cx: position.x,
                cy: position.y,
                r:  size.width / 2
            });
        },

        updateConnectionPreview: function(source, target, vertices) {

            this.svgPreviewConnection.attr({
                d: core_mjs.connectors.rounded(source, target, vertices, {})
            });
        },

        findDirection: function(layoutArea, point) {

            var directions;
            var type = layoutArea.root.get('layout') || layoutArea.getType();
            switch (type) {
                case 'BL-BR':
                case 'TL-TR':
                case 'L-R':
                    directions = type.split('-');
                    return (point.x > layoutArea.rootCX) ? directions[1] : directions[0];
                case 'BL-TL':
                case 'BR-TR':
                case 'B-T':
                    directions = type.split('-');
                    return (point.y > layoutArea.rootCY) ? directions[0] : directions[1];
                case 'L':
                case 'R':
                case 'T':
                case 'B':
                case 'TR':
                case 'TL':
                case 'BR':
                case 'BL':
                    return type;
                default:
                    return layoutArea.direction;
            }
        },

        // @private
        isConnectionValid: function(element, siblings, siblingRank) {

            var parent = siblings.parentArea.root;

            // Banning a loop connection
            if (element.id == parent.id) { return false; }

            // If the element is ancestor of parent, there would be a loop after connection.
            if (this.model.graph.isSuccessor(element, siblings.parentArea.root)) { return false; }

            // If we have same parent, same rank direction an we changing only the siblingRank
            // we allow only changes that actually changes the order of siblings.
            var elementArea = this.model.getLayoutArea(element);
            if (elementArea.parentArea && elementArea.parentArea == siblings.parentArea && elementArea.direction == siblings.direction) {
                var rankChange = elementArea.siblingRank - siblingRank;
                if (rankChange === 0 || rankChange === 1) { return false; }
            }

            // Custom validation
            var validationFn = this.options.validateConnection;
            if (typeof validationFn === 'function') {
                return validationFn.call(this, element, parent, this);
            }

            return true;
        },

        // Interaction
        canInteract: function(handler) {

            return function(cellView) {
                if (this.options.canInteract(cellView)) {
                    handler.apply(this, arguments);
                }
            }.bind(this);
        },

        startDragging: function(elements) {

            var draggedElements = Array.isArray(elements) ? elements : [elements];
            if (!core_mjs.util.isEmpty(draggedElements)) {
                this.delegateDocumentEvents(null, {
                    moveCounter: 0,
                    draggedElements: draggedElements
                });
            }
        },

        onPointerdown: function(elementView) {

            this.startDragging(elementView.model);
        },

        onPointermove: function(evt) {

            var data = evt.data;
            var paper = this.options.paper;
            var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });

            if (data.moveCounter === paper.options.clickThreshold) {

                this._startDrag(data.draggedElements, localPoint.x, localPoint.y);

            } else if (data.moveCounter > paper.options.clickThreshold) {

                this._doDrag(data.draggedElements, localPoint.x, localPoint.y);
            }

            data.moveCounter++;
        },

        onPointerup: function(evt) {

            var data = evt.data;
            var paper = this.options.paper;

            if (data.moveCounter >= paper.options.clickThreshold) {

                var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });

                this._finishDrag(data.draggedElements, localPoint.x, localPoint.y);
            }

            this.undelegateDocumentEvents();
        }

    });

    exports.TreeLayoutView = TreeLayoutView;

}(this.joint.ui = this.joint.ui || {}, $, joint));
