/*! Rappid v3.0.1 - HTML5 Diagramming Framework

Copyright (c) 2015 client IO

 2019-08-10 


This Source Code Form is subject to the terms of the Rappid License
, v. 2.0. If a copy of the Rappid License was not distributed with this
file, You can obtain one at http://jointjs.com/license/rappid_v2.txt
 or from the Rappid archive as was distributed by client IO. See the LICENSE file.*/


this.joint = this.joint || {};
(function (exports, $, core_mjs) {
    'use strict';

    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;

    // Navigator

    var Navigator = core_mjs.mvc.View.extend({

        className: 'navigator',

        events: {
            'mousedown': 'startAction',
            'touchstart': 'startAction',
            'mousedown .joint-paper': 'scrollTo',
            'touchstart .joint-paper': 'scrollTo'
        },

        documentEvents: {
            'mousemove': 'doAction',
            'touchmove': 'doAction',
            'mouseup': 'stopAction',
            'touchend': 'stopAction'
        },

        options: {
            paperConstructor: core_mjs.dia.Paper,
            paperOptions: {},
            /**
             * @deprecated use zoom instead
             */
            zoomOptions: null,
            zoom: { min: 0.5, max: 2 },
            width: 300,
            height: 200,
            padding: 10
        },

        init: function() {

            if (this.options.zoomOptions) {
                // backward compatibility
                this.options.zoom = core_mjs.util.assign({}, this.options.zoom, this.options.zoomOptions);
            } else if (this.options.zoom) {
                this.options.zoom = core_mjs.util.defaults({}, this.options.zoom, this.constructor.prototype.options.zoom);
            }

            core_mjs.util.bindAll(this, 'updateCurrentView', 'doAction', 'stopAction', 'scrollTo');

            // The updateCurrentView is called everytime paperScroller's scrollbars change
            // or the paper is resized. Resize of the paper is normally also acompanied
            // by a scrollbar change (but doesn't have to be). An event is triggered for
            // the vertical and horizontal scrollbar change. That leads to the updateCurrentView
            // to be called upto 4 times per one paperScroller action. Debouncing the method solves
            // this issue but there is definitely room for improvement.
            // + it solves an issue with wrong target paper position while zooming out a paper with
            // negative x-origin
            this.updateCurrentView = core_mjs.util.debounce(this.updateCurrentView, 0);

            var paperScroller = this.options.paperScroller;
            paperScroller.$el.on(("scroll" + (this.getEventNamespace())), this.updateCurrentView);

            var sourcePaper = this.sourcePaper = paperScroller.options.paper;
            this.listenTo(sourcePaper, 'resize', this.updatePaper);

            this.targetPaper = new this.options.paperConstructor(core_mjs.util.merge({
                model: sourcePaper.model,
                interactive: false,
                frozen: true
            }, this.options.paperOptions));
        },

        render: function() {

            this.targetPaper.$el.appendTo(this.el);
            this.targetPaper.unfreeze();

            this.$currentView = $('<div>').addClass('current-view');

            if (this.options.zoom) {
                var $currentViewControl = $('<div>').addClass('current-view-control');
                this.$currentView.append($currentViewControl);
            }

            this.$el.append(this.$currentView).css({
                width: this.options.width,
                height: this.options.height,
                padding: this.options.padding
            });

            // setting right target paper dimension for the first time.
            this.updatePaper(this.sourcePaper.options.width, this.sourcePaper.options.height);

            return this;
        },

        // Updates the navigator's paper size and transformations
        updatePaper: function(width, height) {

            var sourceOrigin = this.sourcePaper.options.origin;
            var sourceScale = this.sourcePaper.scale();
            var navigatorWidth = this.options.width - 2 * this.options.padding;
            var navigatorHeight = this.options.height - 2 * this.options.padding;

            width /= sourceScale.sx;
            height /= sourceScale.sy;

            var ratio = this.ratio = Math.min(navigatorWidth / width, navigatorHeight / height);
            var ox = sourceOrigin.x * ratio / sourceScale.sx;
            var oy = sourceOrigin.y * ratio / sourceScale.sy;

            width *= ratio;
            height *= ratio;

            this.targetPaper.setDimensions(width, height);
            this.targetPaper.setOrigin(ox, oy);
            this.targetPaper.scale(ratio, ratio);

            this.updateCurrentView();
        },

        // Updates the position and size of the navigator's current view rectangle.
        updateCurrentView: function() {

            var ratio = this.ratio;
            var sourceScale = this.sourcePaper.scale();
            var paperScroller = this.options.paperScroller;
            var topLeftCoordinates = paperScroller.clientToLocalPoint(0, 0);
            var paperPosition = this.targetPaper.$el.position();
            var paperOrigin = this.targetPaper.translate();

            // IE returns translate.ty = NaN when ty = 0. It sets transform attribute to 'translate(tx)'.
            // TODO: handle this in the vectorizer
            paperOrigin.ty = paperOrigin.ty || 0;

            this.currentViewGeometry = {
                top: paperPosition.top + topLeftCoordinates.y * ratio + paperOrigin.ty,
                left: paperPosition.left + topLeftCoordinates.x * ratio + paperOrigin.tx,
                width: paperScroller.$el.innerWidth() * ratio / sourceScale.sx,
                height: paperScroller.$el.innerHeight() * ratio / sourceScale.sy
            };

            this.$currentView.css(this.currentViewGeometry);
        },

        startAction: function(evt) {

            evt = core_mjs.util.normalizeEvent(evt);
            var clientX = evt.clientX;
            var clientY = evt.clientY;

            // click on current-view control starts zooming
            // otherwise paper panning is initiated.
            var action = $(evt.target).hasClass('current-view-control') ? 'zooming' : 'panning';
            var ref = this;
            var options = ref.options;
            var currentViewGeometry = ref.currentViewGeometry;
            var sourcePaper = ref.sourcePaper;
            var paperScroller = options.paperScroller;

            this.delegateDocumentEvents(null, {
                action: action,
                startClientX: clientX,
                startClientY: clientY,
                startScrollLeft: paperScroller.el.scrollLeft,
                startScrollTop: paperScroller.el.scrollTop,
                startZoom: paperScroller.zoom(),
                startGeometry: currentViewGeometry,
                startScale: sourcePaper.scale()
            });
        },

        doAction: function(evt) {

            evt = core_mjs.util.normalizeEvent(evt);

            var clientX = evt.clientX;
            var clientY = evt.clientY;
            var data = evt.data;
            var ref = this;
            var sourcePaper = ref.sourcePaper;
            var options = ref.options;
            var ratio = ref.ratio;
            var action = data.action;
            var startClientX = data.startClientX;
            var startClientY = data.startClientY;
            var startScrollLeft = data.startScrollLeft;
            var startScrollTop = data.startScrollTop;
            var startZoom = data.startZoom;
            var startGeometry = data.startGeometry;
            var startScale = data.startScale;
            var frameId = data.frameId;
            var paperScroller = options.paperScroller;
            var zoom = options.zoom;

            switch (action) {

                case 'panning': {
                    var ref$1 = sourcePaper.scale();
                    var sx = ref$1.sx;
                    var sy = ref$1.sy;
                    var x = (clientX - startClientX) * sx;
                    var y = (clientY - startClientY) * sy;
                    paperScroller.el.scrollLeft = startScrollLeft + x / ratio;
                    paperScroller.el.scrollTop = startScrollTop + y / ratio;
                    break;
                }

                case 'zooming': {
                    // x / width is the ratio of the original width and the requested width
                    var width = startGeometry.width;
                    var zoomRatio = 1 + (startClientX - clientX) / width / startScale.sx;
                    core_mjs.util.cancelFrame(frameId);
                    data.frameId = core_mjs.util.nextFrame(function () {
                        paperScroller.zoom(zoomRatio * startZoom, core_mjs.util.defaults({ absolute: true }, zoom));
                    });
                    break;
                }
            }
        },

        stopAction: function() {

            this.undelegateDocumentEvents();
        },

        // Scrolls the view to the position determined by the event.
        scrollTo: function(evt) {

            evt = core_mjs.util.normalizeEvent(evt);

            var paperOrigin = this.targetPaper.translate();
            // TODO: see updateCurrentView method
            paperOrigin.ty = paperOrigin.ty || 0;

            var offsetX, offsetY;
            // There is no offsetX/offsetY property in the Firefox event
            if (evt.offsetX === undefined) {
                var targetPaperOffset = this.targetPaper.$el.offset();
                offsetX = evt.pageX - targetPaperOffset.left;
                offsetY = evt.pageY - targetPaperOffset.top;
            } else {
                offsetX = evt.offsetX;
                offsetY = evt.offsetY;
            }

            var cx = (offsetX - paperOrigin.tx) / this.ratio;
            var cy = (offsetY - paperOrigin.ty) / this.ratio;

            this.options.paperScroller.center(cx, cy);
        },

        onRemove: function() {

            this.targetPaper.remove();
            this.options.paperScroller.$el.off(this.getEventNamespace());
        }
    });

    exports.Navigator = Navigator;

}(this.joint.ui = this.joint.ui || {}, $, joint));
